**队列**

队列是限制结点插入操作固定在一端进行,而结点的删除操作固定在另一端进行的线线性表。队列遵循先入先出。

**使用数组模拟简单队列**

代码见（ArrayQueueDemo.java）

注:该实现下的队列只能做一次性使用，当队列满后因为未重置首位位置和清空数据，导致该数组队列无法重复使用。

**实现环形队列**

上文实现的普通队列无法复用，原因是指针达到最大值之后没有进行回环，环形队列在指针达到最大且没有被填满时，队尾rear会回环重复使用。

而在这种情况下，就可能出现rear反而小于front的情况，既队尾反而在队首之前的场景。此时判断队列是否已满，是否为空，有效数据量的逻辑就发生了变化。

在环形队列中，数组的最后一个空间是放空的，即长度为5的数组，只能填充4个数据。当数据被填满时，rear=4。当数据在最后一位被取出时，front=3。做这种处理是为了分辨rear=front时队列是已满还是为空。这个空位置，主要就是为了用来区分队空与队满情况的。

**1.判断是否已满，已空：**

由于会出现回环情况，此时rear和front比较会出现三种情况：

1) rear>front：此时队尾在队首之前，可以看作未发生回环，而这种场景下队列已满的情况为rear+1 = maxSize 且front=0，也可记为(rear +1 ) % maxSize = front。

这种场景下队列的有效数据量为 rear，也可记为(rear + maxSize - front) % maxSize，当队列为空时不会出现这种场景。

2) rear=front：此时队首和队尾在一起，表示队列已被全部取出，此时队列为空。这种场景下，队列的数据量为0，也可记为(rear + maxSize - front) % maxSize

3) rear<front：此时队尾在队首之前，说明发生回环，这种场景下判断队列已满的情况为rear +1 的位置是front的位置。可以记为rear+1 = front 也可以记为(rear +1 ) % maxSize = front。

这种场景下，队列的有效数据量为(rear + maxSize - front)，也可记为(rear + maxSize - front) % maxSize

综合起来，判断已满的条件为：

【(rear +1 ) % maxSize = front】；判断已空的条件为【rear=front】

队列中有效数据的个数为:

(rear + maxSize - front) % maxSize

代码见（CircularQueueDemo.java）

